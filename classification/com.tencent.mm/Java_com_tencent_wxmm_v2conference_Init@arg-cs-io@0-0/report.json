{
  "analysis": {
    "tool": {
      "model_name": "gpt-5.1",
      "apk_path": "APKs/com.tencent.mm/base.apk",
      "version": "1.0"
    },
    "app": {
      "app_name": "WeChat",
      "package": "com.tencent.mm",
      "min_sdk": 21,
      "target_sdk": 29,
      "version_name": "8.0.28",
      "version_code": "2240"
    },
    "analysisResults": [
      {
        "crash": {
          "ProcessTermination": "google::protobuf::internal::WireFormatLite::SkipField",
          "StackTrace": [
            "google::protobuf::internal::WireFormatLite::SkipField",
            "??",
            "google::protobuf::MessageLite::ParseFromArray",
            "??",
            "??",
            "Java_com_tencent_wxmm_v2conference_Init",
            "fuzz_one_input",
            "main"
          ],
          "JNIBridgeMethod": "Java_com_tencent_wxmm_v2conference_Init",
          "JavaCallGraph": [],
          "FuzzHarnessEntry": "fuzz_one_input",
          "ProgramEntry": "main",
          "LibMap": {
            "APKs/com.tencent.mm/lib/arm64-v8a/libconfService.so": [
              "Java_com_tencent_wxmm_v2conference_Init",
              "Java_com_tencent_wxmm_v2conference_Init"
            ]
          }
        },
        "assessment": {
          "chain_of_thought": [
            "Top native frame is google::protobuf::internal::WireFormatLite::SkipField, called from ParseFromArray, which in this binary is a thin wrapper around a function pointer PTR_ParseFromArray_00245da8. The first application-level native frame below this is FUN_0012aea0 (Init in ConfCallMgr.cpp) which calls google::protobuf::MessageLite::ParseFromArray((void *)(param_1 + 0xc0),(int)param_3).",
            "Decompiled FUN_0012aea0 shows it is the implementation of an Init method for a conference call manager. It logs parameters, validates a number of fields, and uses the parsed protobuf structure extensively. The second argument param_2 is saved to *(long *)(param_1 + 0x1d0). The third argument param_3 (a pointer to envInfo data) and fourth argument param_4 (its length) are passed in from the JNI bridge: Java_com_tencent_wxmm_v2conference_Init obtains a jobject or pointer uVar3 from param_3 and then calls (*DAT_00246048)(DAT_00246048,DAT_00246060,uVar3,param_4). Thus, in the Init implementation, param_3 is that pointer, and param_4 is the length.",
            "Within FUN_0012aea0, the call to ParseFromArray is: google::protobuf::MessageLite::ParseFromArray((void *)(param_1 + 0xc0),(int)param_3). This is suspicious: according to the Google Protobuf API, ParseFromArray(void* data, int size) expects the pointer as first parameter and the length as second. Here, the first parameter is (void *)(param_1 + 0xc0), clearly an internal object (the message object to be populated), and the second parameter is cast from param_3, which is the pointer to the envInfo buffer. The length (param_4) is not passed at all. So the arguments are reversed/misused: the parser is treating a pointer value as a size and an internal object as source data buffer. That can easily lead to out-of-bounds or invalid memory access inside the protobuf library, ultimately causing WireFormatLite::SkipField to crash when walking bogus wire data.",
            "Data-flow: JNI bridge Java_com_tencent_wxmm_v2conference_Init uses param_3 and param_4 from Java; these are attacker-controlled via envInfo passed from the app or, in the fuzzing harness, from the fuzzer input. Inside the Init function, only basic non-zero checks are done: if ((param_2 == 0) || (param_3 == 0) || (param_4 < 1)) it aborts. There is no constraint on the numeric value of param_3 beyond non-nullity. When cast to int and used as the second argument to ParseFromArray, param_3 can be huge or otherwise invalid, potentially causing reads well beyond any real buffer or into unmapped memory. Because ParseFromArray ultimately calls WireFormatLite::SkipField, which operates over the given array and size, this misuse is closely tied to the crash.",
            "We must check whether this is just a harness artifact (e.g., harness passes crazy param_3 that would never be reachable in real app). The JNI bridge obtains uVar3 via a VM call (**(code **)(*param_1 + 0x5c0))(param_1,param_3,0) and passes param_4 unchanged. Normally, in production, param_3 would be a jbyteArray or similar object; the VM helper would map it to a C pointer, and then Init should be called with that pointer and param_4 as length. However, the bug we see is entirely in the native Init implementation; regardless of harness, it takes its own pointer (param_1+0xc0) as data and the pointer param_3 as length. That is a logic bug independent of fuzzer: any real envInfo pointer and length would still be misused in the same way, so the protobuf parser sees nonsense data and can read outrageous lengths. This is a genuine logic and memory safety issue.",
            "The termination is not an ASAN report but a crash in protobuf SkipField; protobuf code generally assumes the provided pointer/length pair is valid and only does limited bounds checks. Providing an enormous length or mismatched pointer can result in out-of-bounds reads or other undefined behaviour. Given this, the condition is exploitable in theory (at least information disclosure or denial-of-service; with careful heap layout, possibly more) but at minimum a high-impact DoS in any privileged context using this native library. However, the context here appears to be an app-side JNI library (libconfService.so) with no evidence that it runs with elevated privileges beyond the app. So from a platform-security perspective, this is more of an app-level bug, but under the provided definition, it qualifies as a security-relevant memory safety vulnerability.",
            "There is clear evidence of attacker-controlled input (envInfo pointer and length from Java) flowing directly into an unsafe use of a library function (ParseFromArray) with swapped/misinterpreted arguments, leading to abnormal behaviour in protobuf and a crash. No sanitizer abort or harness-only code path here; this is mainline Init. Therefore, this should be classified as a real vulnerability, with medium-to-high severity depending on deployment. I will mark it as high due to direct unchecked out-of-bounds read potential and the fact that it is inside a widely used messaging app component.",
            "Because we do not see the exact crash address, we cannot prove control over write primitives or precise code execution, so exploitability is rated as theoretical but realistic for at least DoS and possibly info leak. I will provide exploit details assuming the envInfo data is controllable from the messaging client or via fuzz input, and PoC will be generic ADB commands using a crafted payload via the app interface (placeholders for activity/method names)."
          ],
          "is_vulnerability": true,
          "confidence": 0.92,
          "reasons": [
            "Init implementation (FUN_0012aea0 in ConfCallMgr.cpp) calls google::protobuf::MessageLite::ParseFromArray with arguments reversed/misused: internal object pointer as data and attacker-controlled pointer as size",
            "JNI bridge Java_com_tencent_wxmm_v2conference_Init passes a pointer and length derived from Java envInfo directly into Init with only trivial non-zero checks, so attacker controls the value later cast to the ParseFromArray size parameter",
            "Misuse of ParseFromArray likely causes out-of-bounds reads or invalid memory access inside protobuf WireFormatLite::SkipField, which matches the observed crash",
            "The bug resides in production/native code (not in the fuzz harness) and will be triggered whenever Init is called with typical envInfo, making it a realistic, app-reachable memory-safety vulnerability"
          ],
          "cwe_ids": [
            "CWE-686",
            "CWE-787",
            "CWE-754"
          ],
          "severity": "high",
          "affected_libraries": [
            "libconfService.so"
          ],
          "evidence": [
            {
              "function": "Java_com_tencent_wxmm_v2conference_Init",
              "address": "0x00125de8",
              "file": "libconfService.so",
              "snippet": "uVar3 = (**(code **)(*param_1 + 0x5c0))(param_1,param_3,0);\niVar1 = (**(code **)*DAT_00246048)(DAT_00246048,DAT_00246060,uVar3,param_4);",
              "note": "JNI bridge obtains a pointer from Java envInfo (param_3) and passes it with length param_4 into the native Init implementation"
            },
            {
              "function": "FUN_0012aea0 (Init in ConfCallMgr.cpp)",
              "address": "0x0012aea0",
              "file": "libconfService.so",
              "snippet": "if (((param_2 == 0) || (param_3 == 0)) || (param_4 < 1)) { ... }\n*(long *)(param_1 + 0x1d0) = param_2;\nuVar9 = google::protobuf::MessageLite::ParseFromArray((void *)(param_1 + 0xc0),(int)param_3);\nif ((uVar9 & 1) == 0) { MMTWriteLog(2,\"ConfCallMgr.cpp\",0x8f,\"Init\",\"ERR: Init fail, parse envInfo fail\"); ... }",
              "note": "Second argument to ParseFromArray is cast from param_3 (pointer), not the size (param_4); first argument is an internal object, not the envInfo data pointer"
            },
            {
              "function": "google::protobuf::MessageLite::ParseFromArray",
              "address": "0x0011a770",
              "file": "libconfService.so",
              "snippet": "void google::protobuf::MessageLite::ParseFromArray(void *param_1,int param_2)\n{\n  (*(code *)PTR_ParseFromArray_00245da8)(param_1,param_2);\n  return;\n}",
              "note": "Thin wrapper calling into protobuf; relies on caller to supply correct data pointer and length, which Init violates, leading to crash in WireFormatLite::SkipField"
            }
          ],
          "call_sequence": [
            "fuzz_one_input -> Java_com_tencent_wxmm_v2conference_Init @ 0x00125de8 -> FUN_0012aea0 @ 0x0012aea0 (Init) -> google::protobuf::MessageLite::ParseFromArray @ 0x0011a770 -> google::protobuf::internal::WireFormatLite::SkipField"
          ],
          "recommendations": [
            "Fix the Init implementation to call ParseFromArray with the correct argument order: the envInfo data pointer (param_3/uVar3) as the first argument and its validated length (param_4) as the second",
            "Add strict bounds checking and type validation for all JNI inputs (param_2, param_3, param_4) before using them in parsing or memory operations, and use explicit types (e.g., size_t) instead of casting pointers to int",
            "Add fuzz and unit tests around envInfo parsing using protobuf to catch similar parameter-misuse and ensure graceful failure on malformed input"
          ],
          "assumptions": [
            "param_3 in FUN_0012aea0 is indeed the envInfo data pointer obtained from Java and not some other opaque handle",
            "PTR_ParseFromArray_00245da8 is the standard protobuf MessageLite::ParseFromArray implementation expecting (const void* data, int size)",
            "The application passes attacker-influenced envInfo buffers/lengths from Java to the native Init via JNI in production, not only in the fuzz harness"
          ],
          "limitations": [
            "Exact crash address and register state inside WireFormatLite::SkipField are not available, so we cannot prove the exact form of memory corruption beyond abnormal access",
            "The Java-side code that constructs and passes envInfo to the JNI Init method was not inspected, so actual external controllability of envInfo is inferred from the JNI signature and typical usage",
            "We did not analyze the internal implementation of PTR_ParseFromArray_00245da8; conclusions are based on standard protobuf behaviour"
          ],
          "exploit": {
            "exploitability": "theoretical",
            "trigger_method": "Malformed envInfo protobuf data and/or crafted values for envInfo pointer/length passed via JNI to v2conference.Init",
            "prerequisites": [
              "Ability to supply or influence the envInfo buffer and length in the Java layer before calling the native v2conference.Init method",
              "App installed with the vulnerable libconfService.so and JNI method Java_com_tencent_wxmm_v2conference_Init exposed to the app code",
              "No additional native-side validation or sandboxing preventing abnormal lengths from reaching ParseFromArray"
            ],
            "exploit_pipeline": [
              "Craft an envInfo buffer that, when parsed as a protobuf with a mismatched pointer/length, causes protobuf to read beyond valid bounds or into sensitive memory",
              "In the Java layer (or through the app UI/API), call the v2conference Init method so that its JNI bridge passes the crafted envInfo pointer and its length to the native Init",
              "Inside Init, the pointer is mistakenly cast to an int and used as the ParseFromArray size while the message object pointer is used as the data pointer, leading protobuf to interpret arbitrary memory as wire data",
              "Trigger a crash or out-of-bounds read in WireFormatLite::SkipField, causing application DoS and potentially leaking data via side channels or error handling",
              "Iterate and tune payloads to explore whether controllable heap layout and length can yield more precise memory disclosure or control"
            ],
            "poc_commands": [
              "adb push /path/to/crafted_envinfo.bin /sdcard/Download/crafted_envinfo.bin",
              "adb shell am start -n <package.name>/<main.Activity> --es envinfo_path /sdcard/Download/crafted_envinfo.bin",
              "adb logcat | grep -i \"ConfCallMgr\""
            ],
            "poc_files": [
              "/sdcard/Download/crafted_envinfo.bin"
            ],
            "notes": "PoC assumes there is an activity or entrypoint that reads a file into a byte[] envInfo and passes it to the JNI v2conference.Init method. Replace <package.name>/<main.Activity> with the actual package and activity once known."
          }
        },
        "statistics": {
          "time": "00:01:01",
          "llm_requests": 9,
          "llm_tool_calls": 8,
          "input_tokens": 68250,
          "output_tokens": 2936
        }
      },
      {
        "crash": {
          "ProcessTermination": "__memcpy",
          "StackTrace": [
            "__memcpy",
            "google::protobuf::internal::WireFormatLite::ReadString",
            "??",
            "google::protobuf::MessageLite::ParseFromArray",
            "??",
            "??",
            "Java_com_tencent_wxmm_v2conference_Init",
            "fuzz_one_input",
            "main"
          ],
          "JNIBridgeMethod": "Java_com_tencent_wxmm_v2conference_Init",
          "JavaCallGraph": [],
          "FuzzHarnessEntry": "fuzz_one_input",
          "ProgramEntry": "main",
          "LibMap": {
            "APKs/com.tencent.mm/lib/arm64-v8a/libconfService.so": [
              "Java_com_tencent_wxmm_v2conference_Init",
              "Java_com_tencent_wxmm_v2conference_Init"
            ]
          }
        },
        "assessment": {
          "chain_of_thought": [
            "Top native frame is __memcpy, but that’s a libc allocator/utility; I must look at the first application-level frame below, which is google::protobuf::internal::WireFormatLite::ReadString, then higher-level protobuf parse and finally the JNI entry Java_com_tencent_wxmm_v2conference_Init in libconfService.so.",
            "Ghidra only shows me symbols for the JNI function, not for the internal protobuf functions; decompiling Java_com_tencent_wxmm_v2conference_Init shows it does not itself call memcpy or directly parse any buffers. Instead it delegates to GetWXConfService and then through a virtual function call on DAT_00246048, passing in DAT_00246060 and a handle uVar3 derived from param_3, with param_4 passed as-is.",
            "The crash is in __memcpy during protobuf ReadString while parsing data inside that service call. However, I lack visibility into the implementation of the service object or the exact protobuf parsing code; I can’t see the immediate memcpy site (source/dest/len) to reason about bounds. The stack suggests malformed protobuf data (from fuzz input) led to an invalid length used by memcpy.",
            "I need to trace attacker control. JNI parameters: param_1 is JNIEnv*, param_2 likely jclass or jobject, param_3 and param_4 are Java arguments. The JNI stub obtains uVar3 via a JNIEnv virtual function (*param_1+0x5c0)(param_1,param_3,0) and then calls (*DAT_00246048)(DAT_00246048,DAT_00246060,uVar3,param_4). So attacker influence can come via param_3 and param_4 from Java. The fuzz harness fuzz_one_input presumably passes arbitrary data into param_3 (likely a byte[] or ByteBuffer) and maybe size via param_4.",
            "Within Java_com_tencent_wxmm_v2conference_Init I don’t see any length validation: it just forwards whatever uVar3 and param_4 are to the service. That suggests potential for misuse, but I must distinguish between a real vulnerability and a harness-only protobuf misuse. In a realistic app, param_3 and param_4 would be constructed by trusted app code, not arbitrary external data; external network/files would also usually be parsed/validated before being passed here. A fuzzer that directly mutates the serialized protobuf or native buffer may bypass such higher-level checks, leading to crashes that are not reachable in production.",
            "The termination reason is __memcpy (likely buffer overflow or OOB read/write). However, I can’t see any unchecked memcpy call in the JNI function itself, and the actual memcpy inside protobuf libraries is standard: protobuf’s WireFormatLite::ReadString typically reads a length-delimited field and then copies bytes; if the input buffer is too small, protobuf code usually checks bounds and returns an error instead of calling memcpy with oversized length. A crash inside memcpy might indicate memory was already corrupted or that the code is compiled without full checks, but without decompilation of protobuf functions I can’t prove a bug in app code versus corrupted internal state from unrealistic fuzz inputs.",
            "Given the definition of vulnerability: we need clear evidence of unsafe behavior reachable with attacker-controlled data under realistic use. Here, we only know: (1) fuzzing JNI directly with opaque internal parameters caused a memcpy crash deep inside protobuf; (2) no obvious unsafe JNI glue (no manual memcpy) and no evidence that the app passes unvalidated external data directly to protobuf without length checks; (3) this path likely expects well-formed protobuf messages produced by the same app or service, not arbitrary attacker-controlled data.",
            "This strongly suggests a harness/environment issue: the fuzzer simulates impossible or heavily malformed states (e.g., corrupt internal handles, invalid protobuf wire format) leading to corruption. Without seeing the protobuf parse implementation or Java-side argument construction, I must default to non-vulnerability per guidelines, especially since this looks like a local app crash with no privilege escalation or persistent DoS, only during fuzzing.",
            "Therefore I’ll classify as not a confirmed security vulnerability, with low confidence of exploitability and mark as benign / environment-induced crash. I’ll mention that deeper analysis of the protobuf implementation would be needed to upgrade this to a real vuln, but current data is insufficient."
          ],
          "is_vulnerability": false,
          "confidence": 0.35,
          "reasons": [
            "Crash occurs inside __memcpy during protobuf parsing (WireFormatLite::ReadString) with no direct unsafe memcpy in JNI layer",
            "JNI entry Java_com_tencent_wxmm_v2conference_Init only forwards parameters to an internal service object without manual buffer or length handling",
            "Fuzz harness likely passes unrealistic/malformed internal data (param_3/param_4) not reflective of actual app usage, causing protobuf to operate on corrupted state",
            "No code-level evidence that attacker-controlled external data can reach the crashing memcpy under realistic conditions"
          ],
          "cwe_ids": [],
          "affected_libraries": [
            "libconfService.so"
          ],
          "evidence": [
            {
              "function": "Java_com_tencent_wxmm_v2conference_Init",
              "address": "0x00125de8",
              "file": "libconfService.so",
              "snippet": "uVar3 = (**(code **)(*param_1 + 0x5c0))(param_1,param_3,0);\niVar1 = (**(code **)*DAT_00246048)(DAT_00246048,DAT_00246060,uVar3,param_4);",
              "note": "JNI stub passes a handle derived from param_3 and raw param_4 to an internal service without performing memcpy or buffer arithmetic itself."
            },
            {
              "function": "__memcpy",
              "note": "Top crash frame; implementation in libc, not in app code. Immediate cause likely invalid length or pointer from deeper protobuf logic, not JNI glue."
            }
          ],
          "call_sequence": [
            "fuzz_one_input -> Java_com_tencent_wxmm_v2conference_Init @ 00125de8 -> internal service call (*DAT_00246048)(...) -> protobuf::MessageLite::ParseFromArray -> protobuf::internal::WireFormatLite::ReadString -> __memcpy"
          ],
          "recommendations": [
            "Obtain and analyze the protobuf parsing implementation used by the internal service for potential missing bounds checks around memcpy",
            "Add defensive argument validation in Java_com_tencent_wxmm_v2conference_Init (e.g., ensure param_3 buffer length and param_4 size are sane) to harden against misuse",
            "Constrain JNI fuzzing to realistic data formats that mirror actual Java-side construction to reduce harness-only crashes"
          ],
          "assumptions": [
            "fuzz_one_input passes arbitrary data directly into JNI parameters without Java-side validation",
            "Protobuf parsing functions are standard library code not modified by the app",
            "In production, param_3/param_4 are not directly attacker-controlled but built by trusted app logic"
          ],
          "limitations": [
            "No decompiled view of google::protobuf::* functions to inspect exact memcpy usage and bounds checks",
            "Java-side constructors for v2conference.Init arguments are unavailable, so real-world taint from external inputs cannot be fully traced",
            "Crash log lacks precise fault address and memory maps, limiting analysis of whether this is OOB read vs write"
          ]
        },
        "statistics": {
          "time": "00:00:39",
          "llm_requests": 5,
          "llm_tool_calls": 4,
          "input_tokens": 31806,
          "output_tokens": 1739
        }
      },
      {
        "crash": {
          "ProcessTermination": "__memcpy",
          "StackTrace": [
            "__memcpy",
            "std::__ndk1::basic_string<char, std::__ndk1::char_traits<char>, std::__ndk1::allocator<char> >::append",
            "google::protobuf::io::CodedInputStream::ReadStringFallback",
            "google::protobuf::internal::WireFormatLite::ReadString",
            "??",
            "google::protobuf::MessageLite::ParseFromArray",
            "??",
            "??",
            "Java_com_tencent_wxmm_v2conference_Init",
            "fuzz_one_input",
            "main"
          ],
          "JNIBridgeMethod": "Java_com_tencent_wxmm_v2conference_Init",
          "JavaCallGraph": [],
          "FuzzHarnessEntry": "fuzz_one_input",
          "ProgramEntry": "main",
          "LibMap": {
            "APKs/com.tencent.mm/lib/arm64-v8a/libconfService.so": [
              "Java_com_tencent_wxmm_v2conference_Init",
              "Java_com_tencent_wxmm_v2conference_Init"
            ]
          }
        },
        "assessment": {
          "chain_of_thought": [
            "Top frame is __memcpy inside std::string::append, called from protobuf CodedInputStream::ReadStringFallback, then WireFormatLite::ReadString, then MessageLite::ParseFromArray. This is classic protobuf parsing of a length-delimited string from an untrusted buffer. A memcpy crash here strongly suggests out-of-bounds read/write or length misuse based on encoded length vs actual array size.",
            "Need to identify first application-level native frame below allocators: here, that’s not __memcpy nor std::string, nor protobuf internals, but the function(s) that call ParseFromArray. Stack shows two unknown frames between WireFormatLite::ReadString and MessageLite::ParseFromArray and then up to Java_com_tencent_wxmm_v2conference_Init. We have decompiled that JNI function in libconfService.so. It calls a GetWXConfService and then invokes a function pointer on DAT_00246048 with args (this, DAT_00246060, uVar3, param_4). uVar3 is obtained from a JNI env function pointer at offset 0x5c0 (likely GetByteArrayElements or similar) using param_3; param_4 is directly passed from Java. That function pointer invocation likely eventually triggers protobuf parsing with fuzz input.",
            "We are required to do memcpy-argument dataflow analysis. However, __memcpy is in system libc; in app code we can’t directly inspect it here. Instead we look at CodedInputStream::ReadStringFallback etc., but they’re in another lib (likely libprotobuf.so) which might not be in this project; still, semantic knowledge of protobuf: ReadStringFallback reads varint length into a uint32 len, ensures enough bytes remaining via CodedInputStream buffer limits, then appends to std::string with reserve; however, older protobuf versions have had issues if user supplies extremely large lengths leading to allocation failures or length overflows. However, most modern protobuf implementations check limits, but fuzzers still sometimes crash them via OOM or asserts.",
            "Is this a genuine vulnerability vs just protobuf rejecting malformed data? The crash is in memcpy, meaning it actually dereferenced invalid memory. That happens if dest or src pointer or length is invalid. For protobuf, src is the serialized buffer pointer, dest is inside std::string internal buffer. src could be out-of-bounds if CodedInputStream was created with wrong size bounds (e.g., using ParseFromArray with claimed length > actual), so that it trusts the caller-provided size. In our stack, MessageLite::ParseFromArray is called by intermediate unknown function(s) in app or service code. Those functions likely create CodedInputStream with pointer and length coming from JNI input param_3/param_4 without verifying that param_4 actually matches array length. Under fuzz harness, fuzz_one_input likely passes arbitrary size and data via Java to native Init, into param_3/param_4, so length may be inconsistent with actual buffer, causing OOB in protobuf memcpy.",
            "Need to see JNI param usage. Decompilation of Java_com_tencent_wxmm_v2conference_Init: it only passes param_3 and param_4 to a service method via uVar3 and param_4. uVar3 is from (**(code **)(*param_1 + 0x5c0))(param_1,param_3,0); this looks like GetDirectBufferAddress or GetByteArrayElements; param_4 is probably the length or an int from Java specifying buffer size. There’s no validation at this JNI level. The real parsing and memcpy occur deeper, but controlled by these values that ultimately stem from Java/fuzzer input. Thus, attack-controlled data can influence length and contents processed by protobuf leading to memcpy overflow or underrun—this is a potential memory corruption vulnerability.",
            "However, consider harness vs real app: fuzz_one_input is the harness; in real app, Java_com_tencent_wxmm_v2conference_Init may be passed only well-formed protobuf messages from trusted sources (e.g., internal signaling). If untrusted network or IPC data can reach this, then vulnerability is security-relevant; otherwise it is just a robustness bug. Since we don’t see validation and protobuf parsing is generic, it is plausible untrusted remote data drives it in conferencing context, so treat as potential vulnerability with moderate confidence.",
            "Severity: memcpy OOB in native code implies potential high-impact memory corruption, so severity high. CWE likely CWE-787 Out-of-bounds Write or CWE-125 Out-of-bounds Read; since crash indicates memcpy, could be both but we pick CWE-787 as primary.",
            "Call sequence: fuzz_one_input → Java_com_tencent_wxmm_v2conference_Init → function pointer *(DAT_00246048) (init-like) → protobuf::MessageLite::ParseFromArray → WireFormatLite::ReadString → CodedInputStream::ReadStringFallback → std::string::append → __memcpy. Evidence: decompiled Init shows no checks; function pointer call passes attacker-controlled buffer and length. We lack direct decompilation of the protobuf frame, but its well-known behaviour plus crash location supports vulnerability.",
            "Confidence not maximal because we haven’t decompiled the intermediate function that sets up ParseFromArray and CodedInputStream, and we don’t know exact bounds checks there. But given typical patterns and crash, label as vulnerability with ~0.7 confidence.",
            "Exploit path: attacker supplies crafted serialized protobuf with malformed string length fields or inconsistent total length; native Init parses it and protobuf performs memcpy out-of-bounds, leading to crash and possibly memory corruption. PoC: use adb to start the app and feed a crafted payload into wherever v2conference Init is called (e.g., through app UI or IPC). Without exact IPC details, we keep these generic and note assumptions."
          ],
          "is_vulnerability": true,
          "confidence": 0.7,
          "reasons": [
            "Crash occurs in __memcpy during std::string::append from protobuf ReadStringFallback, indicating out-of-bounds memory access while copying attacker-controlled data.",
            "JNI entry Java_com_tencent_wxmm_v2conference_Init passes a pointer and length derived from Java/fuzzer input into a function pointer that eventually calls protobuf::MessageLite::ParseFromArray without visible validation at native boundary.",
            "Mis-sized or malformed protobuf input can cause CodedInputStream to trust incorrect length values, leading memcpy to read or write beyond the intended buffer, which is a memory corruption risk."
          ],
          "cwe_ids": [
            "CWE-787"
          ],
          "severity": "high",
          "affected_libraries": [
            "libconfService.so"
          ],
          "evidence": [
            {
              "function": "Java_com_tencent_wxmm_v2conference_Init",
              "file": "libconfService.so",
              "snippet": "uVar3 = (**(code **)(*param_1 + 0x5c0))(param_1,param_3,0);\niVar1 = (**(code **)*DAT_00246048)(DAT_00246048,DAT_00246060,uVar3,param_4);",
              "note": "JNI function obtains a raw pointer from Java argument param_3 and passes it with param_4 (length) directly into a service function pointer without validation. This service path leads to protobuf parsing and memcpy crash."
            },
            {
              "function": "__memcpy",
              "note": "Top crashing frame; called via std::string::append during protobuf ReadStringFallback/ReadString when processing serialized data."
            },
            {
              "function": "google::protobuf::MessageLite::ParseFromArray",
              "note": "Parses an array using a pointer and size that ultimately originate from JNI inputs; misuse of size can cause out-of-bounds accesses in internal memcpy operations."
            }
          ],
          "call_sequence": [
            "fuzz_one_input",
            "Java_com_tencent_wxmm_v2conference_Init",
            "*(DAT_00246048) service init/parse",
            "google::protobuf::MessageLite::ParseFromArray",
            "google::protobuf::internal::WireFormatLite::ReadString",
            "google::protobuf::io::CodedInputStream::ReadStringFallback",
            "std::__ndk1::basic_string<>::append",
            "__memcpy"
          ],
          "recommendations": [
            "Identify and decompile the service function behind DAT_00246048 to confirm how ParseFromArray is called and add strict bounds checks on the input length before creating CodedInputStream.",
            "In Java_com_tencent_wxmm_v2conference_Init, validate that param_4 does not exceed the actual size of param_3 and enforce sane maximum message sizes before passing buffers into native parsing.",
            "Update or configure protobuf parsing to enforce size limits (SetTotalBytesLimit / SetRecursionLimit) and robustly handle malformed lengths without triggering memcpy overflows."
          ],
          "assumptions": [
            "The function pointer DAT_00246048 eventually invokes protobuf::MessageLite::ParseFromArray with the pointer and length derived from JNI parameters.",
            "Java-side code or fuzz harness allows attacker-controlled bytes and size to flow into param_3 and param_4, respectively.",
            "No additional validation or length correction occurs in the unknown intermediate native frames between the JNI entry and ParseFromArray."
          ],
          "limitations": [
            "Intermediate native frames (between JNI entry and protobuf parsing) were not decompiled, so existence of hidden bounds checks cannot be fully ruled out.",
            "Exact protobuf library version and its internal safety checks (e.g., maximum string length, total bytes limits) are unknown.",
            "The real-world attack surface (how external/untrusted data reaches Java_com_tencent_wxmm_v2conference_Init) is not visible from the fuzzing context."
          ],
          "exploit": {
            "exploitability": "theoretical",
            "trigger_method": "Crafted protobuf-like binary data passed to the v2conference Init JNI bridge (directly or via harness).",
            "prerequisites": [
              "Ability to supply arbitrary or partially controlled binary data to the component that calls Java_com_tencent_wxmm_v2conference_Init.",
              "Knowledge of or ability to guess the protobuf message structure enough to manipulate length fields.",
              "Target device running an app version using libconfService.so with the vulnerable Init path exposed to untrusted input."
            ],
            "exploit_pipeline": [
              "Craft a serialized protobuf payload where a length-delimited field (string/bytes) advertises an excessively large or inconsistent length compared to the actual buffer size.",
              "Deliver this payload through the app path that invokes Java_com_tencent_wxmm_v2conference_Init (e.g., via a network message, IPC, or local file that the app parses).",
              "When Init is called, the JNI code passes the raw buffer pointer and claimed size into the native service, which in turn calls MessageLite::ParseFromArray.",
              "Protobuf parsing reaches ReadStringFallback and std::string::append, which call memcpy with invalid length and/or pointer, causing an out-of-bounds access and process crash, potentially enabling memory corruption exploitation in a controlled environment."
            ],
            "poc_commands": [
              "adb push /path/to/crafted_payload.bin /sdcard/Download/payload.bin",
              "adb shell am start -n <package>/<Activity> --es input_path /sdcard/Download/payload.bin",
              "# Alternatively, if a test harness exists:\nadb shell /data/local/tmp/<app_binary> /sdcard/Download/payload.bin"
            ],
            "poc_files": [
              "/sdcard/Download/payload.bin"
            ],
            "notes": "The exact intent extras, activity name, or IPC mechanism are unknown; placeholders should be replaced with real component names once the app wiring to Java_com_tencent_wxmm_v2conference_Init is identified."
          }
        },
        "statistics": {
          "time": "00:00:40",
          "llm_requests": 2,
          "llm_tool_calls": 1,
          "input_tokens": 13079,
          "output_tokens": 2474
        }
      },
      {
        "crash": {
          "ProcessTermination": "??",
          "StackTrace": [
            "??",
            "google::protobuf::MessageLite::ParseFromArray",
            "??",
            "??",
            "Java_com_tencent_wxmm_v2conference_Init",
            "fuzz_one_input",
            "main"
          ],
          "JNIBridgeMethod": "Java_com_tencent_wxmm_v2conference_Init",
          "JavaCallGraph": [],
          "FuzzHarnessEntry": "fuzz_one_input",
          "ProgramEntry": "main",
          "LibMap": {
            "APKs/com.tencent.mm/lib/arm64-v8a/libconfService.so": [
              "Java_com_tencent_wxmm_v2conference_Init",
              "Java_com_tencent_wxmm_v2conference_Init"
            ]
          }
        },
        "assessment": {
          "chain_of_thought": [
            "Identify first app-level native frame: stack shows google::protobuf::MessageLite::ParseFromArray above Java_com_tencent_wxmm_v2conference_Init. The concrete implementation in this lib is a thin wrapper calling function pointer PTR_ParseFromArray_00245da8; the actual parsing code (and crash site) is external/indirect and not visible here.",
            "Decompiled JNI entry Java_com_tencent_wxmm_v2conference_Init: it initializes a global service object via GetWXConfService and then calls its virtual method with (service, context, envInfoBuffer, envInfoLen). That call maps to FUN_0012aea0 (Init in ConfCallMgr.cpp).",
            "Decompiled FUN_0012aea0 (Init): parameters (this, appCtx, envInfoBuf, envInfoLen). It logs inputs, then validates: if param_2==0 or param_3==0 or param_4<1, it logs invalid param and returns -1. So envInfoBuf and envInfoLen must be non-null and length >=1 to reach protobuf parsing.",
            "The code then stores appCtx, and calls google::protobuf::MessageLite::ParseFromArray((void*)(this+0xc0),(int)param_3). NOTE: The second argument is param_3 (envInfoBuf pointer), NOT param_4 (envInfoLen). This is a clear bug: ParseFromArray expects (void* data, int size). Passing a pointer as size gives an effectively unbounded length, leading to OOB read/write inside protobuf parsing.",
            "Thus, even though we cannot see inside PTR_ParseFromArray_00245da8, the incorrect second argument is evident. This is a memory safety bug originating in app code, not harness: envInfoBuf and envInfoLen are controlled (indirectly) by caller/Java. JNI Init passes a buffer obtained from JNIEnv via GetByteArrayElements or similar (we don't see exact code but pattern is standard). Fuzzer controls that Java array, so taint flows to envInfoBuf pointer; but the *length* passed to ParseFromArray is the pointer value, not attacker-chosen integer. However, the bogus length can be extremely large (address in high memory) causing protobuf to overrun buffers or access invalid memory and crash.",
            "Even if the protobuf implementation bounds-checks or aborts on invalid size, this is still an unsafe API misuse that can cause out-of-bounds access or at minimum denial-of-service. In a real app scenario, envInfoBuf should be a serialized protobuf message of controlled size; here a logic error would still allow a crash for any non-trivial pointer value. Since Init is a public/native entry likely called from app startup, malformed envInfo (e.g., from network or Intent) could crash the app repeatedly (DoS).",
            "Required memcpy/memmove analysis: Within FUN_0012aea0 there are several memcpy/memmove/operator_new patterns for string and vector management. Relevant one for crash linkage is misused ParseFromArray rather than a local memcpy. None of the memcpy calls use attacker-controlled lengths without checks: allocations are sized based on existing container sizes and have overflow checks (e.g., uVar9 >> 0x3e != 0 leads to abort). The only clearly unsafe length is the wrong argument to ParseFromArray.",
            "Backward data flow for ParseFromArray args: dest = this+0xc0, fully internal; src/len pointer = param_3 (JNI envInfoBuf). Param_3 comes from vtable call in JNI Init, whose arguments include param_3 from JNI (jbyteArray or buffer) and param_4 (length). There is no revalidation or correction before passing to ParseFromArray; the bug is local to FUN_0012aea0.",
            "Given this, the root cause is a logic bug leading to potential OOB behavior in third-party protobuf library, triggered by fuzzer-controlled envInfoBuf pointer (through JNI). While we lack the exact crash reason (termination ??), the misuse is sufficiently clear to label this as a likely memory-corruption vulnerability of at least high severity."
          ],
          "is_vulnerability": true,
          "confidence": 0.9,
          "reasons": [
            "Clear API misuse: google::protobuf::MessageLite::ParseFromArray called with buffer pointer as size instead of envInfo length",
            "Arguments originate indirectly from JNI input; Init validates only non-null and len>=1 but never fixes the mismatch, so bug is reachable under realistic inputs",
            "Protobuf parser will interpret huge size value, enabling out-of-bounds memory access or allocator misuse, which is a memory safety issue"
          ],
          "cwe_ids": [
            "CWE-686",
            "CWE-787"
          ],
          "severity": "high",
          "affected_libraries": [
            "libconfService.so"
          ],
          "evidence": [
            {
              "function": "FUN_0012aea0 (Init in ConfCallMgr.cpp)",
              "address": "0012aea0",
              "file": "libconfService.so",
              "snippet": "*(long *)(param_1 + 0x1d0) = param_2;\n// BUG: second argument should be envInfoLen (param_4), but code passes envInfoBuf pointer (param_3)\nuVar9 = google::protobuf::MessageLite::ParseFromArray((void *)(param_1 + 0xc0),(int)param_3);\nif ((uVar9 & 1) == 0) {\n  MMTWriteLog(2,\"ConfCallMgr.cpp\",0x8f,\"Init\",\"ERR: Init fail, parse envInfo fail\");\n  return -3;\n}",
              "note": "Incorrect argument ordering to ParseFromArray; size parameter is a pointer value."
            },
            {
              "function": "Java_com_tencent_wxmm_v2conference_Init",
              "address": "00125de8",
              "file": "libconfService.so",
              "snippet": "uVar3 = (**(code **)(*param_1 + 0x5c0))(param_1,param_3,0);\niVar1 = (**(code **)*DAT_00246048)(DAT_00246048,DAT_00246060,uVar3,param_4);",
              "note": "JNI bridge passes envInfoBuf and envInfoLen into virtual Init; these map to param_3 and param_4 of FUN_0012aea0."
            },
            {
              "function": "google::protobuf::MessageLite::ParseFromArray",
              "address": "0011a770",
              "file": "libconfService.so",
              "snippet": "void google::protobuf::MessageLite::ParseFromArray(void *param_1,int param_2)\n{\n  (*(code *)PTR_ParseFromArray_00245da8)(param_1,param_2);\n}",
              "note": "Thin wrapper; actual implementation expects (buffer,size) and will trust the size argument."
            }
          ],
          "call_sequence": [
            "fuzz_one_input -> Java_com_tencent_wxmm_v2conference_Init -> ConfService::Init (vtable) -> FUN_0012aea0 (Init) -> google::protobuf::MessageLite::ParseFromArray"
          ],
          "recommendations": [
            "Fix ParseFromArray call to use the correct length parameter: ParseFromArray((void*)(this+0xc0),(int)param_4) instead of param_3.",
            "Add unit tests around ConfCallMgr::Init to validate that envInfo parsing uses the actual buffer length and that malformed envInfo does not cause crashes or undefined behavior.",
            "Consider adding sanity checks on envInfoLen before parsing (e.g., reasonable upper bound) and handle protobuf parse failures gracefully."
          ],
          "assumptions": [
            "The virtual method invoked from Java_com_tencent_wxmm_v2conference_Init is indeed FUN_0012aea0 (Init in ConfCallMgr.cpp).",
            "google::protobuf::MessageLite::ParseFromArray behaves per standard protobuf semantics, trusting the size argument for reads/writes.",
            "The crash observed by the fuzzer stems from misuse of ParseFromArray rather than unrelated harness issues."
          ],
          "limitations": [
            "Exact crash signal and address are unknown (termination marked as ??), so precise memory-corruption pattern cannot be confirmed.",
            "The concrete implementation behind PTR_ParseFromArray_00245da8 is not visible in this binary; detailed corruption path inside protobuf parsing cannot be inspected.",
            "Java-side code for building the envInfo buffer is not available, so external reachability (network/IPC) path is inferred, not proven."
          ],
          "exploit": {
            "exploitability": "theoretical",
            "trigger_method": "Malformed envInfo buffer passed through JNI v2conference.Init",
            "prerequisites": [
              "Ability to cause the app to call v2conference.Init with attacker-controlled envInfo data (e.g., via crafted configuration, network payload, or IPC).",
              "Target device running a build that includes libconfService.so with this Init implementation."
            ],
            "exploit_pipeline": [
              "Craft an envInfo payload (arbitrary bytes) that will be passed to v2conference.Init from the Java layer, ensuring the underlying native buffer pointer resides at a high address so that its value interpreted as an int is large.",
              "Deliver this payload via the mechanism the app uses to obtain conference configuration (e.g., network response, configuration file, or Intent extras).",
              "Trigger the app functionality that leads to Java_com_tencent_wxmm_v2conference_Init being invoked, causing JNI to create a byte array and pass its pointer and length into the native Init function.",
              "In native code, FUN_0012aea0 misuses envInfoBuf as the size argument to ParseFromArray, causing protobuf parsing to overrun buffers or access invalid memory, leading to a crash and possible memory corruption.",
              "Iterate payloads and monitor with ASan or similar tools to determine if the corruption can be shaped toward control-flow hijacking (e.g., overwriting adjacent heap metadata or vtable pointers within protobuf-managed objects)."
            ],
            "poc_commands": [
              "adb push /path/to/crafted_envinfo.bin /sdcard/Download/envinfo.bin",
              "adb shell am start -n <PACKAGE>/<MAIN_ACTIVITY> --es envinfo_path \"/sdcard/Download/envinfo.bin\"",
              "# Inside a custom test build or harness: invoke the JNI method directly\nadb shell \"cd /data/local/tmp && ./jni_test_runner --method Java_com_tencent_wxmm_v2conference_Init --envinfo /sdcard/Download/envinfo.bin\""
            ],
            "poc_files": [
              "/sdcard/Download/envinfo.bin"
            ],
            "notes": "Because the size parameter to ParseFromArray is derived from a pointer, precise exploitation depends on how the protobuf implementation allocates and parses internal fields. This is at least a reliable crash/DoS and may be further exploitable with heap grooming in a real environment."
          }
        },
        "statistics": {
          "time": "00:00:38",
          "llm_requests": 7,
          "llm_tool_calls": 7,
          "input_tokens": 54633,
          "output_tokens": 2410
        }
      },
      {
        "crash": {
          "ProcessTermination": "google::protobuf::internal::WireFormatLite::SkipField",
          "StackTrace": [
            "google::protobuf::internal::WireFormatLite::SkipField",
            "google::protobuf::internal::WireFormatLite::SkipField",
            "??",
            "google::protobuf::MessageLite::ParseFromArray",
            "??",
            "??",
            "Java_com_tencent_wxmm_v2conference_Init",
            "fuzz_one_input",
            "main"
          ],
          "JNIBridgeMethod": "Java_com_tencent_wxmm_v2conference_Init",
          "JavaCallGraph": [],
          "FuzzHarnessEntry": "fuzz_one_input",
          "ProgramEntry": "main",
          "LibMap": {
            "APKs/com.tencent.mm/lib/arm64-v8a/libconfService.so": [
              "Java_com_tencent_wxmm_v2conference_Init",
              "Java_com_tencent_wxmm_v2conference_Init"
            ]
          }
        },
        "assessment": {
          "chain_of_thought": [
            "Crash reports WireFormatLite::SkipField as termination point, which in this binary is a thin wrapper calling through an imported function pointer PTR_SkipField_00245db8; we don’t see an abort/ASAN reason, just that execution stops there.",
            "SkipField is a standard protobuf helper used while parsing; huge xref list shows many generated message parsing functions call it, but the decompiled JNI entry Java_com_tencent_wxmm_v2conference_Init never touches protobuf directly and instead calls GetWXConfService and then an indirect virtual method on DAT_00246048 with a buffer obtained from Java (via a JNIEnv function pointer at *param_1+0x5c0).",
            "We are missing the implementation of GetWXConfService and the service’s ParseFromArray / protobuf-using code where SkipField is ultimately reached; the stack shows google::protobuf::MessageLite::ParseFromArray above SkipField, but we don’t have its body here. That’s inside protobuf and not necessarily buggy; SkipField normally just advances over unknown fields and should not crash on its own.",
            "Given no SIGSEGV/ASAN context and that SkipField is just an indirect call into external protobuf runtime, the most likely explanation is that the fuzz harness is feeding malformed or random data as the config/protobuf blob to the Init method, and the underlying service or protobuf library is aborting (or throwing) internally when encountering invalid wire format or resource limits, leading to process termination.",
            "We see no direct unsafe memory ops (memcpy/memmove) or arithmetic in Java_com_tencent_wxmm_v2conference_Init; it mainly sets globals, allocates 8 bytes, calls a constructor-like FUN_00129df4, then calls a virtual Init-like method on DAT_00246048 and cleans up on error. The arguments passed into the service method include uVar3, obtained via a JNIEnv call that likely returns a Java byte array pointer or similar, plus param_4. There is no bounds check here because the JNIEnv abstraction is handling array length, and protobuf’s ParseFromArray expects the buffer size that the service should be passing; we don’t see that call site, so we cannot assert a miscomputed length or overflow.",
            "Because we lack the decompilation of the service method and the protobuf ParseFromArray wrapper in this binary, we cannot show a concrete out-of-bounds read/write or UAF. We just know that malformed fuzz input reached protobuf parsing and triggered termination inside SkipField/ParseFromArray, which is usually treated as parse failure or at worst a functional crash (DoS of this app only).",
            "Under the definition given, a mere local crash/DoS in this unprivileged conference library, without evidence of memory corruption or privilege boundary crossing, is not considered a security vulnerability; it’s a robustness bug triggered by unrealistic fuzz harness inputs. Therefore default to non-vulnerability with low confidence that there might be a deeper protobuf bug, but no evidence here."
          ],
          "is_vulnerability": false,
          "confidence": 0.35,
          "reasons": [
            "Termination occurs inside google::protobuf::internal::WireFormatLite::SkipField, which in this binary is a thin wrapper to an imported protobuf function pointer with no visible unsafe logic.",
            "JNI entry Java_com_tencent_wxmm_v2conference_Init does not itself perform unchecked memory copies or arithmetic; it delegates to an external service where protobuf parsing occurs, and those implementations are not available here for inspection.",
            "Observed effect is at most a crash during parsing of malformed data, i.e. local DoS of the app; no concrete evidence of memory corruption, attacker-controlled pointer, or exploitable condition is present."
          ],
          "cwe_ids": [],
          "severity": "low",
          "affected_libraries": [
            "libconfService.so"
          ],
          "evidence": [
            {
              "function": "Java_com_tencent_wxmm_v2conference_Init",
              "address": "0x00125de8",
              "file": "libconfService.so",
              "snippet": "if (DAT_00246048 == (undefined8 *)0x0) {\n  ...\n  DAT_00246048 = (undefined8 *)GetWXConfService(0x134899d);\n  plVar2 = (long *)operator_new(8);\n  FUN_00129df4();\n  DAT_00246060 = plVar2;\n  if (DAT_00246048 != (undefined8 *)0x0) {\n    uVar3 = (**(code **)(*param_1 + 0x5c0))(param_1,param_3,0);\n    iVar1 = (**(code **)*DAT_00246048)(DAT_00246048,DAT_00246060,uVar3,param_4);\n    (**(code **)(*param_1 + 0x600))(param_1,param_3,uVar3,0);\n    ...\n  }\n}",
              "note": "JNI init method delegates to service virtual method with data obtained from Java; no direct protobuf or memcpy usage here."
            },
            {
              "function": "google::protobuf::internal::WireFormatLite::SkipField",
              "address": "0x0011a790",
              "file": "libconfService.so",
              "snippet": "void google::protobuf::internal::WireFormatLite::SkipField(CodedInputStream *param_1,uint param_2)\n{\n  (*(code *)PTR_SkipField_00245db8)(param_1,param_2);\n}\n",
              "note": "Thin wrapper calling imported protobuf runtime; no visible unsafe arithmetic or bounds checks here."
            }
          ],
          "call_sequence": [
            "fuzz_one_input",
            "Java_com_tencent_wxmm_v2conference_Init @ 0x00125de8",
            "GetWXConfService (external, not decompiled)",
            "[service virtual Init method]",
            "google::protobuf::MessageLite::ParseFromArray",
            "google::protobuf::internal::WireFormatLite::SkipField @ 0x0011a790"
          ],
          "recommendations": [
            "Obtain and analyze the implementation of the GetWXConfService-provided Init method and its protobuf parsing code to check for miscomputed lengths or unchecked parsing failures.",
            "Add defensive checks and error handling around protobuf ParseFromArray results to prevent whole-process termination on malformed data.",
            "If protobuf is built with abort-on-corruption options, consider configuring it to return errors instead, limiting impact to failed operations instead of crashes."
          ],
          "assumptions": [
            "fuzz_one_input passes arbitrary or highly malformed data into Java_com_tencent_wxmm_v2conference_Init, not representative of normal app use.",
            "The protobuf runtime and SkipField implementation reside in external code not visible in this binary, so we cannot inspect their internal safety properties.",
            "The crash does not involve a privileged process or system service but only this app/library."
          ],
          "limitations": [
            "No view of GetWXConfService’s returned object implementation or its virtual Init method, which likely calls protobuf parsing.",
            "No crash signal/PC/fault address details (e.g., SIGSEGV at address) are provided, so we can’t categorically rule in or out memory corruption inside protobuf.",
            "Java-side call graph is empty, so we cannot determine real-world reachability or constraints on the data passed into Init."
          ]
        },
        "statistics": {
          "time": "00:00:29",
          "llm_requests": 6,
          "llm_tool_calls": 6,
          "input_tokens": 41376,
          "output_tokens": 1793
        }
      }
    ]
  }
}